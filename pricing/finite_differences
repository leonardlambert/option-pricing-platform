import copy
import numpy as np

# ---- Pricing interface ----
def price_option(model, p):
    if model == "BSM":
        return bs_price(p)
    elif model == "VG":
        return vg_price_stub(p)  # stub ok for review
    else:
        raise ValueError("Unknown model")

def bs_price(p):
    # minimal BSM (assume imported norm, etc.)
    S,K,T,r,sigma,typ = p["S"],p["K"],p["T"],p["r"],p["sigma"],p["type"]
    # ... standard formula ...
    return price

def vg_price_stub(p):
    # placeholder deterministic pricing call
    return price

# ---- Finite difference Greeks ----
def fd_greek(price_fn, p, key, eps):
    p_up = copy.deepcopy(p)
    p_dn = copy.deepcopy(p)
    p_up[key] += eps
    p_dn[key] -= eps
    return (price_fn(p_up) - price_fn(p_dn)) / (2*eps)

def compute_greeks_fd(model, p):
    price_fn = lambda pp: price_option(model, pp)

    eps_S = max(1e-4*p["S"], 0.01)
    eps_sigma = 1e-3
    eps_T = 1/365

    return {
        "delta": fd_greek(price_fn, p, "S", eps_S),
        "vega":  fd_greek(price_fn, p, "sigma", eps_sigma),
        "theta": -fd_greek(price_fn, p, "T", eps_T),
    }

# ---- One sanity test ----
params = dict(S=100, K=100, T=0.5, r=0.03, sigma=0.2, type="call")
print(compute_greeks_fd("BSM", params))
